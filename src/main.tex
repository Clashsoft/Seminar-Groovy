%%
%% Author: adriankunz
%% 2018-12-28
%%

% =============== Preamble ===============

% --------------- Definitions ---------------
\newcommand{\paperTitle}[0]{Die Sprache Groovy}
\newcommand{\paperSubtitle}[0]{Seminar Skriptsprachen, Wintersemester 2018/19}
\newcommand{\paperDate}[0]{\today}
\newcommand{\paperKeywords}[0]{Groovy, Seminar, Skriptsprachen}
\newcommand{\paperAuthor}[0]{Adrian Kunz}

% --------------- Commands ---------------
\newcommand{\code}[1]{\mintinline{java}{#1}}

\newcommand{\codelisting}[3]{
\begin{listing}
	\inputminted{#1}{#1/#2}
	\caption{#3}
	\label{lst:#2}
\end{listing}
}

% --------------- Document Setup ---------------
\documentclass[11pt,a4paper]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2cm]{geometry}

\title{\paperTitle}
\author{\paperAuthor}
\date{\paperDate}

% --------------- Packages ---------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}

% Minted
\usepackage{minted}
\usemintedstyle{vs}
\setminted{frame=single,tabsize=2,linenos}

% Hyperref
\usepackage{hyperref}
\hypersetup{
pdftitle={\paperTitle{}},
pdfauthor={\paperAuthor{}},
pdfsubject={\paperTitle{}},
pdfkeywords={\paperKeywords},
bookmarksnumbered=true,
bookmarksopen=true,
hidelinks,
}
\usepackage{hypcap}

% =============== Document ===============

\begin{document}
	% --------------- ---------------

	\maketitle

	\tableofcontents

	% --------------- ---------------

	\section{Einleitung}\label{sec:einleitung}

	Hier folgt die Einleitung.

	% --------------- ---------------

	\section{Sprache}\label{sec:sprache}

	Im folgenden Abschnitt wird Groovy als Sprache vorgestellt.
	Die Syntax ist stark auf Java und andere C-ähnliche Sprachen angelehnt.
	Deshalb wird im Unterabschnitt~\ref{subsec:vergleichMitJava} durchgeführt ein Vergleich mit Java durchgeführt.
	Dabei wird sowohl auf syntaktischer als auch auf semantischer Ebene Bezug genommen.
	In Unterabschnitt~\ref{subsec:besonderheiten} werden neue Sprachelemente und Besonderheiten dargestellt.

	Bei Groovy handelt es sich {u.a.} um eine Skriptsprache.
	Somit sollten Groovy-Programme einfach auszuführen sein, möglichst ohne Zwischenschritte wie etwa ein Aufruf eines Compilers.
	Groovy-Skripte können entsprechend mit dem \code{groovy}-Programm ausgeführt werden.
	Wie etwa bei Bash oder Python können Groovy-Dateien (\code{.groovy}) aber auch mit einer Shebang-Zeile beginnen, um sie direkt ausführbar zu machen.
	Variablen und Statements können direkt in der obersten Ebene platziert werden, ebenso Imports, Klassen und Methoden.

	\codelisting{groovy}{hello-world.groovy}{Hello World in Groovy}

	Das Codebeispiel~\ref{lst:hello-world.groovy} kann mit dem Befehl  \code{groovy hello-world.groovy} ausgeführt werden;
	es kann durch das Shebang aber auch direkt als \code{./hello-world.groovy} aufgerufen werden\footnote{Dafür muss der Programmcode in einer Datei namens \code{hello-world.groovy} gespeichert werden; der Aufruf via Shebang setzt voraus, dass diese ausführbar ist.}.

	Die Ausgabe ist in beiden Fällen \code{Hello World!}.
	Auffällig ist das Schlüsselwort \code{def}, der Methodenaufruf von \code{println} ohne Klammern und die Zeichenkette mit Interpolierung.
	Auf diese wird entsprechend in den Unterabschnitten~\ref{subsubsec:dynamische-typen},~\ref{subsubsec:optionale-syntax} und~\ref{subsubsec:string-interpolierung} näher eingegangen.

	Zu beachten ist, dass es sich zwar um ein Skript handelt, aber Groovy dennoch in jedem Fall vor der Ausführung kompiliert wird.
	Bei Skripts geschieht dieser Schritt jedoch ohne dass zusätzliche Dateien gespeichert werden;
	der generierte Bytecode wird nur im Arbeitsspeicher zwischengespeichert und am Ende der Ausführung verworfen.

	\subsection{Vergleich mit Java}\label{subsec:vergleichMitJava}

	Da ein Großteil der Sprachelemente und deren Syntax direkt übernommen wurde, ist es möglich, viele Java-Programme direkt als Groovy-Programm zu verwenden.
	Dies hat einerseits den Vorteil, dass bei der Überführung eines Projekts von Java zu Groovy zunächst nur wenige Änderungen vorgenommen werden müssen.
	Andererseits macht es das Erlernen der Sprache für Entwickler mit einem Java-Hintergrund einfacher, da sie direkt gültigen Groovy-Code schreiben können und sich mit der Zeit spezifische Konzepte aneignen können.

	Es gibt jedoch einige Fälle, in denen ein Java-Programm nicht auch ein Groovy-Programm ist.
	Triviale Beispiele sind jene Programme, in denen Schlüsselwörter von Groovy als Bezeichner verwendet werden.
	Zu den Kontrollstrukturen, die Groovy in Version 2 nicht unterstützt, gehören Do-While-Schleifen, Try-With-Resource- Blöcke und Block-Statements.
	Die Java-Syntax für Lambda-Ausdrücke, Methoden-Referenzen und Array-Initialisierung werden von dieser Version auch nicht unterstützt.
	In Groovy 3~\cite{groovy-lang:release3}, welches sich derzeit in Entwicklung befindet, werden jedoch mithilfe eines neuen Parsers Bemühungen betrieben, auch diese Sprachelemente zu erlauben und somit den Umstieg weiter zu erleichtern.

	Unterschiede können auch bei Programmen auftreten, die in beiden Sprachen syntaktisch gültig sind, da sich in einigen Fällen die Semantik in Groovy anders als in Java verhält.
	Dazu gehören das implizite Importieren von Pakete zusätzlich zu \code{java.lang}, dazu gehören {u.a.} \code{java.io}, \code{java.net}, \code{java.util}, \code{groovy.lang} und \code{groovy.util}, sowie die Klassen \code{java.math.BigInteger} und \code{java.math.BigDecimal}.
	Weiterhin verhalten sich innere und geschachtelte Klassen, String- und Char-Literale und Typkonvertierungen zwischen primitiven Typen, Wrapper-Typen, \code{BigInteger} und \code{BigDecimal} anders als in Java.

	Weitere Informationen und Beispiele zu den oben genannten Unterschieden sind bei~\cite{groovy-lang:differences} zu finden.

	\subsubsection{Multi-Methoden}

	Unter Multi-Methoden versteht man eine besondere Art der Semantik von Methodenaufrufen.
	Es handelt sich um eine Form des Polymorphismus, bei der die aufzurufende Methode nicht nur anhand des Laufzeittyps des Empfängers, sondern auch anhand der Typen der Argumente ausgewählt wird.
	In Java werden Methodenaufrufe, bei denen der Aufruf vom Laufzeittyp des Empfängers abhängt, als "virtuell" bezeichnet.
	Dabei ist das \emph{Überschreiben} von Methoden in Unterklassen von Bedeutung.
	Parallel dazu gibt es die Möglichkeit, Methoden zu \code{überladen}.
	Dies bezeichnet das Deklarieren von zwei oder mehr Methoden im gleichen Kontext, die denselben Namen besitzen und sich in der Anzahl der Parameter oder deren Typen unterscheiden.
	Beim Aufruf dieser Methoden wird abhängig von den zur Kompilierungszeit bestimmten Typen der Argument ausgewählt, welche Methode aufgerufen wird.
	Zur Laufzeit sind die Typen der Argument für die Auswahl der Methode dann nicht mehr relevant.

	Zur Verdeutlichung soll~\ref{lst:polycalls} betrachtet werden.
	Es handelt sich bei dem Programmcode um ein Polyglot,
	da er sowohl gültiger Java-Code als auch gültiger Groovy-Code ist.

	% TODO maybe get rid of speak and animals and use Object and String

	\begin{listing}[ht]
		\inputminted{java}{java/PolyCalls.java}
		\caption{Überschreiben und Überladen}
		\label{lst:polycalls}
	\end{listing}

	Bei der Ausführung wird jedoch ein Unterschied in der Ausgabe deutlich.
	Die Aufrufe der virtuellen Methode \code{speak} in Zeile 10 erzeugen beide die Ausgabe \code{woof}
	Hier wird die Implementierung von \code{speak} in der Klasse \code{Dog} ausgewählt, da der Laufzeittyp des Objekts, welches von den Variablen \code{a} und \code{d} referenziert wird, \code{Dog} ist, obwohl \code{a} mit dem statischen Typ \code{Animal} deklariert ist.
	Im ersten Aufruf von \code{take} in Zeile 11 wird in Java und Groovy die zweite \code{take}-Implementierung aufgerufen, die Ausgabe ist entsprechend \code{Dog}.
	Die Ausgabe des zweiten \code{take}-Aufrufs unterscheidet die Programmiersprachen:
	In Java wird die erste Implementierung aufgerufen und \code{Animal} ausgegeben, da der statische Typ von \code{a}, \code{Animal} für die Auswahl herangezogen wird.
	In Groovy wird auch der Laufzeittyp der Argumente betrachtet, dieser ist für das Argument \code{a} \code{Dog}, weshalb auch hier die zweite Implementierung aufgerufen wird.
	Zum Vergleich:
	Die Ausgabe des Programms, als Java-Code ausgeführt, ist \code{woof woof Dog Animal };
	als Groovy-Programm wird \code{woof woof Dog Dog } ausgegeben.

	\subsection{Besonderheiten}\label{subsec:besonderheiten}

	\subsubsection{String-Interpolierung}\label{subsubsec:string-interpolierung}

	\subsubsection{Dynamische Typen}\label{subsubsec:dynamische-typen}

	\subsubsection{Optionale Syntax}\label{subsubsec:optionale-syntax}

	% --------------- ---------------

	\section{Community, Einsatz und Verbreitung}\label{sec:community}

	Groovy wird von vielen Unternehmen verwendet, unter anderen Google, IBM und LinkedIn~\cite{groovy-lang:main,wiki:Groovy}.

	\subsection{Gradle}\label{subsec:gradle}

	\subsection{Grails}\label{subsec:grails}

	% --------------- ---------------

	\section{Zusammenfassung}\label{sec:zusammenfassung}

	% --------------- ---------------

	\bibliography{main}
	\bibliographystyle{ieeetr}

	% --------------- ---------------
\end{document}
