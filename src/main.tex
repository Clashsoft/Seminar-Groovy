%%
%% Author: adriankunz
%% 2018-12-28
%%

% =============== Preamble ===============

% --------------- Definitions ---------------
\newcommand{\paperTitle}[0]{Die Sprache Groovy}
\newcommand{\paperSubtitle}[0]{Seminar Skriptsprachen, Wintersemester 2018/19}
\newcommand{\paperDate}[0]{\today}
\newcommand{\paperKeywords}[0]{Groovy, Seminar, Skriptsprachen}
\newcommand{\paperAuthor}[0]{Adrian Kunz}

% --------------- Commands ---------------
\newcommand{\code}[1]{\mintinline{groovy}{#1}}
\newcommand{\plain}[1]{\mintinline{text}{#1}}

\newcommand{\codelisting}[3]{
\begin{listing}[ht]
	\inputminted{#1}{#1/#2}
	\caption{#3}
	\label{lst:#2}
\end{listing}
}

% --------------- Document Setup ---------------
\documentclass[a4paper]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2cm]{geometry}

\title{\paperTitle}
\author{\paperAuthor}
\date{\paperDate}

% --------------- Packages ---------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}

% Minted
\usepackage{minted}
\usemintedstyle{vs}
\setminted{frame=single,tabsize=2,linenos}

% Hyperref
\usepackage{hyperref}
\hypersetup{
pdftitle={\paperTitle{}},
pdfauthor={\paperAuthor{}},
pdfsubject={\paperTitle{}},
pdfkeywords={\paperKeywords},
bookmarksnumbered=true,
bookmarksopen=true,
hidelinks,
}
\usepackage{hypcap}

% =============== Document ===============

\begin{document}
% --------------- ---------------

\maketitle

% --------------- ---------------

\section{Einleitung}\label{sec:einleitung}

% TODO

% --------------- ---------------

\section{Sprache}\label{sec:sprache}

Im folgenden Abschnitt wird Groovy als Sprache vorgestellt.
Die Syntax ist stark auf Java und andere C-ähnliche Sprachen angelehnt.
Deshalb wird im Unterabschnitt~\ref{subsec:vergleichMitJava} durchgeführt ein Vergleich mit Java durchgeführt.
Dabei wird sowohl auf syntaktischer als auch auf semantischer Ebene Bezug genommen.
In Unterabschnitt~\ref{subsec:besonderheiten} werden neue Sprachelemente und Besonderheiten dargestellt.

Bei Groovy handelt es sich primär um eine Skriptsprache.
Somit sollten Groovy-Programme einfach auszuführen sein, möglichst ohne Zwischenschritte wie etwa ein Aufruf eines Compilers.
Groovy-Skripte können entsprechend mit dem \code{groovy}-Programm ausgeführt werden.
Wie etwa bei Bash oder Python können Groovy-Dateien (\code{.groovy}) aber auch mit einer Shebang-Zeile beginnen, um sie direkt ausführbar zu machen.
Variablen und Statements können direkt in der obersten Ebene platziert werden, ebenso Imports, Klassen und Methoden.

\codelisting{groovy}{hello-world.groovy}{Hello World in Groovy}

Das Listing~\ref{lst:hello-world.groovy} kann mit dem Befehl \code{groovy hello-world.groovy} ausgeführt werden;
es kann durch das Shebang aber auch direkt als \code{./hello-world.groovy} aufgerufen werden\footnote{Dafür muss der Programmcode in einer Datei namens \code{hello-world.groovy} gespeichert werden;
der Aufruf via Shebang setzt voraus, dass diese ausführbar ist.}.
Die Ausgabe ist in beiden Fällen \plain{Hello World!}.
Auffällig ist das Schlüsselwort \code{def}, der Methodenaufruf von \code{println} ohne Klammern und die Zeichenkette mit Interpolierung.
Auf diese wird entsprechend in den Unterabschnitten~\ref{subsubsec:typisierung},~\ref{subsubsec:optionale-syntax} und~\ref{subsubsec:strings} näher eingegangen.

Zu beachten ist, dass es sich zwar um ein Skript handelt, aber Groovy dennoch in jedem Fall vor der Ausführung kompiliert wird.
Bei Skripts geschieht dieser Schritt jedoch ohne dass zusätzliche Dateien gespeichert werden;
der generierte Bytecode wird nur im Arbeitsspeicher zwischengespeichert und am Ende der Ausführung verworfen.

\subsection{Vergleich mit Java}\label{subsec:vergleichMitJava}

Da ein Großteil der Sprachelemente und deren Syntax direkt übernommen wurde, ist es möglich, viele Java-Programme direkt als Groovy-Programm zu verwenden.
Dies hat einerseits den Vorteil, dass bei der Überführung eines Projekts von Java zu Groovy zunächst nur wenige Änderungen vorgenommen werden müssen.
Andererseits macht es das Erlernen der Sprache für Entwickler mit einem Java-Hintergrund einfacher, da sie direkt gültigen Groovy-Code schreiben können und sich mit der Zeit spezifische Konzepte aneignen können.

Es gibt jedoch einige Fälle, in denen ein Java-Programm nicht auch ein Groovy-Programm ist.
Triviale Beispiele sind jene Programme, in denen Schlüsselwörter von Groovy als Bezeichner verwendet werden.
Zu den Kontrollstrukturen, die Groovy in Version 2 nicht unterstützt, gehören Do-While-Schleifen, Try-With-Resource- Blöcke und Block-Statements.
Die Java-Syntax für Lambda-Ausdrücke, Methoden-Referenzen und Array-Initialisierung werden von dieser Version auch nicht unterstützt.
In Groovy 3~\cite{groovy-lang:release3}, welches sich derzeit in Entwicklung befindet, werden jedoch mithilfe eines neuen Parsers Bemühungen betrieben, auch diese Sprachelemente zu erlauben und somit den Umstieg weiter zu erleichtern.

Unterschiede können auch bei Programmen auftreten, die in beiden Sprachen syntaktisch gültig sind, da sich in einigen Fällen die Semantik in Groovy anders als in Java verhält.
Dazu gehören das implizite Importieren von Pakete zusätzlich zu \code{java.lang}, dazu gehören u.a.~\code{java.io}, \code{java.net}, \code{java.util}, \code{groovy.lang} und \code{groovy.util}, sowie die Klassen \code{java.math.BigInteger} und \code{java.math.BigDecimal}.
Weiterhin verhalten sich innere und geschachtelte Klassen, String- und Char-Literale und Typkonvertierungen zwischen primitiven Typen, Wrapper-Typen, \code{BigInteger} und \code{BigDecimal} anders als in Java.

Weitere Informationen und Beispiele zu den oben genannten Unterschieden sind bei~\cite{groovy-lang:differences} zu finden.

\subsubsection{Typisierung}\label{subsubsec:typisierung}

Das Typsystem von Groovy ist standardmäßig dynamisch und unterstützt Duck-Typisierung~\cite[Abs.~6.]{groovy-lang:semantics}.
An vielen Stellen werden implizite Typkonvertierung, beispielsweise von und zu Strings oder Booleans durchgeführt~\cite[Abs.~3.]{groovy-lang:semantics}.
Typinformationen im Code dienen dem Compiler nur als Hilfe um Warnungen auszugeben; Fehler treten jedoch erst zur Laufzeit auf.
Wenn gewünscht ist es aber auch möglich, Typfehler zur Compilezeit zu erzwingen; dafür können die \code{@TypeChecked}- und \code{@CompileStatic}-Annotationen verwendet werden~\cite[Abs.~6.2.]{groovy-lang:semantics}.
Listing~\ref{lst:dynamic-typing.groovy} illustriert das dynamische Verhalten.

\codelisting{groovy}{dynamic-typing.groovy}{Dynamische und Duck-Typisierung in Groovy}

Zunächst wird eine Klasse \code{Duck} mit einer \code{quack}-Methode deklariert.
In Zeile 4 wird die \code{duck}-Variable angelegt, der eine \code{Duck}-Instanz zugewiesen wird.
Der statische Typ der Variable ist durch das \code{def}-Schlüsselwort \code{Object}.
Dennoch ist der Aufruf der \code{quack}-Methode möglich und erzeugt die Ausgabe \plain{quack}.
In der nächsten Zeile wird ein Map-Literal angelegt, welches dem Schlüssel \code{quack} eine Closure zuweist.
Durch den Coercion-Operator \code{as} wird die Map zu einem \code{Duck}-Objekt konvertiert, welches die \code{quack}-Methode überschreibt.
Zeile 6 zeigt, dass \code{duck} noch immer eine Instanz der \code{Duck}-Klasse ist; der \code{quack}-Aufruf erzeugt jedoch nun die Ausgabe \plain{I'm not a duck}.
Da \code{duck} als Variable vom Typ \code{Object} deklariert wurde, ist die Zuweisung eines Strings erlaubt.
Der Aufruf von \code{quack} auf dem String-Objekt wird vom Compiler nicht abgelehnt, führt jedoch zur Laufzeit zu einer \code{MissingMethodException}.
Ändert man die Deklaration zu \code{Duck duck}, wird schon bei der Zuweisung eine \code{GroovyCastException} erzeugt.

\subsubsection{Multi-Methoden}

Ein Unterschied zu Java, der mit der dynamischen Typisierung in Verbindung steht, ist die Auflösung von Methodenaufrufen.
In Java werden diese dynamisch anhand des Empfängertyps (Überschreiben), aber statisch anhand der Argumenttypen (Überladen) aufgelöst.
Bei Groovy sind auch die Laufzeittypen der Argument für die Auswahl entscheidend, was unter dem Begriff Multi-Methoden bekannt ist.
Das Listing~\ref{lst:multi-methods.groovy} erklärt dieses Verhalten.

\codelisting{groovy}{multi-methods.groovy}{Multi-Methoden in Groovy}

Wenn das Programm ausgeführt wird, ist die Assertion erfolgreich und es wird nichts ausgegeben.
Grund dafür ist, dass die \code{take}-Methode aufgerufen wird, welche einen \code{String} erwartet.
Der Laufzeittyp des Arguments \code{o} ist \code{String}, während der statische Typ \code{Object} ist.
Dadurch wählt die Groovy-Laufzeitumgebung dynamisch die \code{take(String)}-Methode aus.
In Java würde die Methodenauswahl zur Kompilierungszeit erfolgen und die \code{take(Object)}-Variante bevorzugen, da dort beim Überladen nur der statische Typ relevant ist.

\subsection{Besonderheiten}\label{subsec:besonderheiten}

Trotz der Anlehnung an Java bringt Groovy auch einige Besonderheiten mit sich.
Selbst elementare Sprachkonzepte wie Strings, Zahlen und boolsche Werte sind vielfältiger.
Listen, Maps und andere Datenstrukturen sind einfacher zu verwenden; auch Null-Sicherheit wird durch die Sprache erleichtert.
Optionale Syntax und Closures ermöglichen es, DSLs zu definieren und verwenden.
Durch Prototyp-Erweiterungen können Methoden zur Laufzeit zu Klassen und einzelnen Instanzen hinzugefügt werden.
Auf die oben genannten Sprachkonzepte wird in diesem Unterabschnitt genauer eingegangen.

\subsubsection{Zahlen}\label{subsubsec:zahlen}

Mathematische Konzepte haben eine besondere Bedeutung in Groovy.
Die Klassen \code{BigInteger} und \code{BigDecimal} sind standardmäßig importiert~\cite[Abs.~1.]{groovy-lang:differences} und leichter zu verwenden als in Java, da sie übliche Operatoren unterstützen.
Um Fließkommafehler zu vermeiden, sind Literale mit Nachkommastellen ohne explizites Suffix oder Cast vom Typ \code{BigDecimal}~\cite[Abs.~5.2.]{groovy-lang:syntax}.
Das Ergebnis von Divisionen ist in vielen Fällen\footnote{wenn einer der beiden Operanden ein \code{float} oder \code{double} ist, ist das Ergebnis vom Typ \code{double}} auch ein \code{BigDecimal}~\cite[Abs.~5.5.1.]{groovy-lang:syntax}.
Der Operator \code{**} kann verwendet werden, um die Potenz einer Zahl zu berechnen~\cite[Abs.~5.5.2.]{groovy-lang:syntax}.

Übliche Operatoren können auch von eigenen Klassen verwendet werden, indem sie Methoden mit besonderen Namen wie \code{plus} für \code{+}, \code{leftShift} für \code{<<} oder \code{next} für \code{++} deklarieren~\cite[Abs.~10.]{groovy-lang:operators}.
Dies macht es möglich, Klassen für mathematische Objekte wie komplexe Zahlen, Brüche oder Polynome zu erstellen und mit Operatoren zu verwenden.
Eigene Operatoren können jedoch nicht definiert werden.

In Groovy verhalten sich primitive Datentypen zu Kompilierungs- und Laufzeit wie Objekte ihrer Wrapper-Klassen~\cite[Abs.~10.]{groovy-lang:differences}.
Somit unterstützen sie die üblichen Funktionalitäten, die sich auf Objekte beziehen.

\subsubsection{Zeichenketten}\label{subsubsec:strings}

Auch Zeichenketten sind vielfältiger als in Java.
Es existieren sechs Arten von String-Literalen in Groovy:

\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}\setlength{\parsep}{0pt}
\item \code{'single quoted'}, unterstützt keine Interpolation oder Zeilenumbrüche,
\item \code{'''triple single quoted'''}, unterstützt keine Interpolation aber mehrere Zeilen,
\item \code{"double quoted"}, unterstützt Interpolation mit dem \code{$}-Zeichen, aber nur einzeilig,
\item \code{"""triple quoted"""}, unterstützt Interpolation und mehrere Zeilen,
\item \code{/slashy/}, für reguläre Ausdrücke, unterstützt auch Interpolation und Zeilenumbrüche, und
\item \code{$/dollar slashy/$}, ähnlich zu \code{/slashy/} aber mit besonderen Escape-Regeln.
\end{itemize}

Besonders interessant ist hierbei die Interpolation, welche ein einfaches Einsetzen von Werten in Strings erlaubt.
Listing~\ref{lst:string-interpolation.groovy} zeigt, wie diese in String-Literalen zum Einsatz kommt.

\codelisting{groovy}{string-interpolation.groovy}{String-Interpolation in Groovy}

Im ersten String-Literal in Zeile 3 wird anstelle von \code{$a} und \code{$b} wird der Wert der Variablen eingesetzt;
\code{${a+b}} wertet den Ausdruck \code{a+b} aus und setzt das Ergebnis in den resultierenden String ein.
Zu beachten ist hier, dass es sich bei dem linken String-Literal in Zeile 3 eigentlich nicht um einen \code{String} handelt, sondern um eine Instanz der Klasse \code{GString}.
Diese speichert auch die Objekte, die anstelle der Platzhalter eingesetzt werden.
Erst der Vergleich mit \code{==} verursacht eine Konvertierung zu \code{String}; dabei werden auch Ersetzung vorgenommen.

In Zeile 5 wird ein GString verwendet, der eine Closure (siehe Unterabschnitt~\ref{subsubsec:closures}) als Platzhalter verwendet.
Diese wird jedes Mal aufgerufen, wenn der GString zu einem String konvertiert wird.
Dabei können auch Seiteneffekte auftreten und der Rückgabewert kann sich ändern.
Im Beispiel ist zu sehen, dass \code{g} jedes mal den Wert von \code{a} erhöht, wenn es durch den Vergleich zu einem String konvertiert wird.
Nach der Zuweisung von \code{a} wird der neue Wert in \code{g} verwendet.
Die Assertions in Zeilen 5 und 7 sind erfolgreich; das Verhalten der Gleichheit ist hier jedoch verwirrend, weshalb solcher Code vermieden werden sollte.

\subsubsection{Listen und Maps}\label{subsubsec:listen-und-maps}

Auch Listen und Maps haben in Groovy erste Bürgerrechte und einen großen Satz von Funktionen, um ihre Verwendung zu erleichtern.
Listing~\ref{lst:lists-and-maps.groovy} zeigt einige Möglichkeiten, Listen und Maps zu verwenden.

\codelisting{groovy}{lists-and-maps.groovy}{Listen und Maps in Groovy}

In Zeile 2 wird zunächst eine Liste mit der \code{[]}-Syntax angelegt;
diese ist ohne explizite Typangabe eine \code{ArrayList}.
In Zeile 4 wird der Index-Operator verwendet, um auf das erste und letzte Element zuzugreifen, dabei ist die Verwendung negativer Zahlen wie etwa in Python möglich.
Danach wird mit dem \code{<<}-Operator ein Element ans Ende der Liste angehängt.
Die 5. Zeile zeigt, dass der Index-Operator auch mehrere Argument sowie Intervalle unterstützt.
Der \code{..}-Operator sowie der nicht-inklusive \code{..<}-Operator sind auch in anderen Kontexten verwendbar, um einfach Intervalle zu definieren, beispielsweise in Foreach-Schleifen.

In Zeile 7 wird eine Map angelegt, zu erkennen an den Schlüssel-Wert-Paaren in den eckigen Klammern.
Bei den Bezeichnern \code{a} und \code{b} handelt es sich nicht um Variablennamen, stattdessen wird hier die Zeichenkette \code{a} bzw. \code{b} als Schlüssel verwendet.
Das erzeugte Objekt verwendet die \code{LinkedHashMap}-Implementierung, damit die Reihenfolge der Schlüssel erhalten bleibt.
Zeile 8 zeigt, wie der Zugriff auf den Wert eines Schlüssels sowohl mit dem Index-Operator als auch mit dem Punkt-Operator möglich ist, als wäre \code{d} eine Klassenvariable.
In der nächsten Zeile werden auch beide Möglichkeiten verwendet, um neue Einträge hinzuzufügen.
Auffällig ist der Zugriff auf unbekannte Schlüssel in Zeile 10, welcher auch mit dem Punkt-Operator möglich ist und in beiden Fällen \code{null} zurückgibt.

Andere Collections und Arrays können durch Coercion von Listen- oder Map-Literalen erzeugt werden.
Weitere Informationen zu Arrays, Listen und Maps sind in~\cite[Abs.~7.-9.]{groovy-lang:syntax} zu finden.

\subsubsection{Null-Sicherheit}

Obwohl Groovy im Kern eine Skriptsprache ist und Sicherheit daher eine kleinere Rolle spielt, ist es dennoch im Bereich Null-Sicherheit besser ausgestattet als Java.
Im Kern stehen dabei zwei sehr nützliche Operatoren, \code{?.} und \code{?:}, welche im Folgenden kurz vorgestellt werden.

Der Safe-Navigation-Operator \code{?.} wird verwendet, um \code{NullPointerException}s zu vermeiden.
Anstelle des \code{.}-Operators für Methoden- und Feldzugriffe sorgt er dafür, dass das Ergebnis des Zugriffs \code{null} ist, wenn der Empfänger \code{null} ist.
Somit ist beispielsweise der Wert von \code{person?.name} gleich \code{null}, wenn \code{person} schon \code{null} ist.

Der \code{?:}-Operator, auch Elvis-Operator genannt, ist ein syntaktischer Zucker der Ausdrücke der Form \code{lhs ?: rhs} durch \code{lhs ? lhs : rhs} ersetzt.
Dies erscheint im ersten Moment nicht nützlich, doch durch die Regeln der Groovy Truth~\cite[Abs.~5.]{groovy-lang:semantics}, welche die implizite Konvertierung zu Bool-Werten bestimmen, ist er sehr mächtig.
Eine Regel besagt, dass \code{null}-Referenzen als \code{falsy}\footnote{In Skriptsprachen wird dieser Begriff häufig für Werte verwendet, die sich in boolschen Ausdrücken wie \code{false} verhalten, aber eigentlich kein boolscher Wert sind.} gelten.
Somit wird \code{rhs} vom Ternary-Operator ausgewählt wird, wenn \code{lhs} \code{null} ist, und \code{lhs} wenn nicht.
Jedoch können die Regeln auch zu Problemen in der Semantik führen:
Leere Strings, Listen und Maps oder Zahlen mit dem Wert \code{0} gelten neben \code{null}-Referenzen auch als \code{falsy}, weshalb der Elvis-Operators mit solchen Werten als linkem Operand auch den rechten Operand zurückgibt.
In der Praxis ist dies jedoch weniger ein Problem, da Variablen mit eben diesen Datentypen, welche gleichzeitig auch \code{null} werden können, aufgrund der Existenz geeigneterer ``Leer''-Werte kein guter Stil sind.

\subsubsection{Optionale Syntax}\label{subsubsec:optionale-syntax}

Groovy erlaubt es, Punkt-Operatoren und Klammern bei Methodenaufrufen wegzulassen.
Dies ermöglicht die einfache Erstellung von DSLs, wie es das Listing~\ref{lst:optional-parens.groovy} zeigt.

\codelisting{groovy}{optional-parens.groovy}{Eine kleine DSL mithilfe von optionalen Klammern und Punkten}

Hier wird zunächst eine Hilfsfunktion \code{make} erstellt, welche die DSL definiert.
Um das Beispiel kurz zu halten, werden hierfür Map-Literale und Closures, die in den Unterabschnitten~\ref{subsubsec:listen-und-maps} und~\ref{subsubsec:closures} erklärt werden.
Bei echten DSLs sollten stattdessen Klassen und Methoden verwendet werden.
Hier wurde zusätzlich ausgenutzt, dass die Verwendung des \code{return}-Schlüsselworts auch optional ist.
In Zeile 5 werden aus Illustrationsgründung symbolische Variablen für einige Zeichenketten definiert.
Danach folgt die Verwendung der definierten DSL:
Der Befehl sieht aus wie ein englischer Satz, ist aber semantisch äquivalent zu der Anweisung in Zeile 7.
Bei den aufeinanderfolgenden Bezeichnern werden abwechselnd Punkt-Zugriffe und Methodenaufrufe impliziert.
Die Ausgabe ist zweimal der Satz \plain{my cake contains sugar, eggs and flour}.

Es fällt auch auf, dass bei diesem und anderen Listings an Zeilenenden keine Semicolons gebraucht werden, da auch diese in den meisten Fällen optional sind.
In Listing~\ref{lst:lists-and-maps.groovy}, Zeile 11 ist zu beobachten, wie mit einem expliziten Semicolon auch mehrere Anweisungen in einer Zeile stehen können.

\subsubsection{Closures}\label{subsubsec:closures}

Neben der optionalen Klammerung sind auch Closures ein wichtiges Werkzeug, um DSLs zu verwirklichen.
Im Kern sind Closures ähnlich zu Lambda-Ausdrücken in Java, indem sie eine Möglichkeit bieten, Anweisungen als Objekt zu übergeben.
Listing~\ref{lst:closures-fp.groovy} zeigt, wie sie für funktionale Operationen auf Listen verwendet werden.

\codelisting{groovy}{closures-fp.groovy}{Funktionale Listenoperationen in Groovy}

Zunächst wird in Zeile 2 eine Liste definiert.
In Zeile 3 wird mithilfe der \code{collect}-Methode eine neue Liste erstellt, die jeweils das Doppelte der Elemente der Ursprungsliste enthält.
Dafür wird eine Closure als Argument übergeben, die einen Parameter \code{it} empfängt und ihn verdoppelt zurückgibt.
Danach werden mit \code{findAll} diejenigen Elemente in eine neue Liste gepackt, die gerade sind.
In Zeile 4 wird mit der \code{inject}-Methode und einer Closure, die zwei Argumente addiert, die Summe über von \code{list} berechnet.
In funktionalen Programmiersprachen sowie in der Java-\code{Stream}-API sind die Operationen \code{collect}, \code{findAll} und \code{inject} meist als \code{map}, \code{filter} und \code{reduce} bzw. \code{fold} bekannt.

Eine Besonderheit von Closures ist, dass Methodenaufrufe und Feldzugriffe im Rumpf nicht an der Stelle verfügbar sein müssen, wo die Closure erstellt wird.
Dafür wird der \code{delegate}-Mechanismus bereitgestellt, der sehr gut für DSLs geeignet ist und im Listing~\ref{lst:closures-dsl.groovy} gezeigt wird.

\codelisting{groovy}{closures-dsl.groovy}{Verwendung von Closure Delegates für eine weitere DSL}

Das Programm beginnt mit der Deklaration der Funktion \code{eval}, welche eine Closure akzeptiert und einen Variable \code{result} speichert.
Danach wird dem \code{delegate} der Closure ein Objekt einer anonymen Klasse zugewiesen, welche die Methoden \code{add} und \code{mul} definiert.
Diese verändern entsprechend die \code{result}-Variable mit dem übergebenen Argument.
In Zeile 6 wird die modifizierte Closure aufgerufen und der Wert der Ergebnisvariable ausgegeben.
Die Verwendung der dadurch definierten DSL, einer einfachen Rechenmaschine, folgt in Zeile 8.
Die Closure, die der \code{eval}-Funktion übergeben wird, bezieht sich auf die in diesem Kontext unbekannten Funktionen \code{add} und \code{mul}.
Diese müssen jedoch erst aufgelöst werden, wenn die Closure aufgerufen wird.
Da zu diesem Zeitpunkt schon das \code{delegate} gesetzt ist, können die bisher unbekannten Funktionen nun über dieses aufgelöst werden, und beziehen sich entsprechend auf die Methoden der anonymen Klasse.
Somit kann das Programm erfolgreich ausgeführt werden und gibt \plain{5.5} aus, das Ergebnis der DSL-Rechenmaschine.

\subsubsection{Prototyp-Erweiterung}

Die Prototyp-Erweiterung ist eine weitere Besonderheit der Methodenauflösung von Groovy.
Sie erlaubt es, Klassen und Objekten Eigenschaften und Methoden zur Laufzeit hinzuzufügen, ohne dass der Quellcode geändert werden muss.
Listing~\ref{lst:prototype-extension.groovy} zeigt, wie diese zur rekursiven Berechnung einer Fakultät verwendet werden kann.

\codelisting{groovy}{prototype-extension.groovy}{Fakultätberechnung mit Prototyp-Erweiterungen}

Hier wird zunächst die \code{factorial}-Methode für das \code{Integer}-Objekt der Zahl \code{0} durch eine Closure definiert, welche den Wert \code{1} zurückgibt (Basisfall).
Danach wird allgemein für die \code{Number}-Klasse der Rekursionsfall definiert.
Hier steht \code{delegate} für den Empfänger.
In Zeile 4 wird schließlich die \code{factorial}-Methode aufgerufen.
Dabei wird zur Laufzeit zuerst in der \code{metaClass} der konkreten Instanz nach einer Definition gesucht, danach in der \code{metaClass} des Laufzeittyps.
Bei dem Aufruf \code{0.factorial()} wird also sofort die Definition aus Zeile 2 aufgerufen;
bei \code{5.factorial()} wird fünf Mal die Definition aus Zeile 3 aufgerufen, bevor \code{delegate} gleich \code{1} ist und \code{(delegate - 1).factorial()} auf die Definition für \code{0} verweist.

% --------------- ---------------

\section{Community, Einsatz und Verbreitung}\label{sec:community}

% TODO

\subsection{Gradle}\label{subsec:gradle}

Gradle~\cite{gradle} ist ein Open-Source-Tool zur Build-Automatisierung, welches in Groovy und Java geschrieben wurde.
Konfiguriert wird es durch Groovy-Skripte, die sich die DSL-Fähigkeiten der Sprache zu Nutze machen.
Dies hebt es von seinen Vorgängern Apache Ant und Apache Maven, welche XML-Dateien verwenden, durch erhöhte Nutzerfreundlichkeit ab.
Seit dem ersten Release 2005 wurde Gradle stets weiterentwickelt, um neben Java und Groovy auch andere Zielsprachen wie Scala und sogar Python und C++ zu unterstützen.
Gradle ist besonders für große Projekte gut geeignet, da durch inkrementelle Builds nur geänderte Dateien verarbeitet werden müssen.

\subsection{Grails}\label{subsec:grails}

Grails~\cite{grails} ist ein in Groovy geschriebenes Web-Framework, welches quelloffen ist.
Es basiert auf Spring Boot, setzt aber auf Konvention statt Konfiguration, um einen leichteren Einstieg zu erlauben.
Datenbankzugriff wird durch das GORM-Toolkit gewährleistet, welches wiederum Schnittstellen für Hibernate, MongoDB und Cassandra bietet.
HTML-Seiten können mit dem Groovy Server Page-Templatesystem generiert werden.

% --------------- ---------------

\section{Zusammenfassung}\label{sec:zusammenfassung}

% TODO

% --------------- ---------------

\bibliography{main}
\bibliographystyle{ieeetr}

% --------------- ---------------
\end{document}
