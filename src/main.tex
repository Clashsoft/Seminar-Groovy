%%
%% Author: adriankunz
%% 2018-12-28
%%

% =============== Preamble ===============

% --------------- Definitions ---------------
\newcommand{\paperTitle}[0]{Die Sprache Groovy}
\newcommand{\paperSubtitle}[0]{Seminar Skriptsprachen, Wintersemester 2018/19}
\newcommand{\paperDate}[0]{\today}
\newcommand{\paperKeywords}[0]{Groovy, Seminar, Skriptsprachen}
\newcommand{\paperAuthor}[0]{Adrian Kunz}

% --------------- Commands ---------------
\newcommand{\code}[1]{\mintinline{java}{#1}}

\newcommand{\codelisting}[3]{
\begin{listing}
	\inputminted{#1}{#1/#2}
	\caption{#3}
	\label{lst:#2}
\end{listing}
}

% --------------- Document Setup ---------------
\documentclass[11pt,a4paper]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2cm]{geometry}

\title{\paperTitle}
\author{\paperAuthor}
\date{\paperDate}

% --------------- Packages ---------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}

% Minted
\usepackage{minted}
\usemintedstyle{vs}
\setminted{frame=single,tabsize=2,linenos}

% Hyperref
\usepackage{hyperref}
\hypersetup{
pdftitle={\paperTitle{}},
pdfauthor={\paperAuthor{}},
pdfsubject={\paperTitle{}},
pdfkeywords={\paperKeywords},
bookmarksnumbered=true,
bookmarksopen=true,
hidelinks,
}
\usepackage{hypcap}

% =============== Document ===============

\begin{document}
	% --------------- ---------------

	\maketitle

	\tableofcontents

	% --------------- ---------------

	\section{Einleitung}\label{sec:einleitung}

	Hier folgt die Einleitung.

	% --------------- ---------------

	\section{Sprache}\label{sec:sprache}

	Im folgenden Abschnitt wird Groovy als Sprache vorgestellt.
	Die Syntax ist stark auf Java und andere C-ähnliche Sprachen angelehnt.
	Deshalb wird im Unterabschnitt~\ref{subsec:vergleichMitJava} durchgeführt ein Vergleich mit Java durchgeführt.
	Dabei wird sowohl auf syntaktischer als auch auf semantischer Ebene Bezug genommen.
	In Unterabschnitt~\ref{subsec:besonderheiten} werden neue Sprachelemente und Besonderheiten dargestellt.

	Bei Groovy handelt es sich {u.a.} um eine Skriptsprache.
	Somit sollten Groovy-Programme einfach auszuführen sein, möglichst ohne Zwischenschritte wie etwa ein Aufruf eines Compilers.
	Groovy-Skripte können entsprechend mit dem \code{groovy}-Programm ausgeführt werden.
	Wie etwa bei Bash oder Python können Groovy-Dateien (\code{.groovy}) aber auch mit einer Shebang-Zeile beginnen, um sie direkt ausführbar zu machen.
	Variablen und Statements können direkt in der obersten Ebene platziert werden, ebenso Imports, Klassen und Methoden.

	\codelisting{groovy}{hello-world.groovy}{Hello World in Groovy}

	Das Codebeispiel~\ref{lst:hello-world.groovy} kann mit dem Befehl  \code{groovy hello-world.groovy} ausgeführt werden;
	es kann durch das Shebang aber auch direkt als \code{./hello-world.groovy} aufgerufen werden\footnote{Dafür muss der Programmcode in einer Datei namens \code{hello-world.groovy} gespeichert werden;
	der Aufruf via Shebang setzt voraus, dass diese ausführbar ist.}.

	Die Ausgabe ist in beiden Fällen \code{Hello World!}.
	Auffällig ist das Schlüsselwort \code{def}, der Methodenaufruf von \code{println} ohne Klammern und die Zeichenkette mit Interpolierung.
	Auf diese wird entsprechend in den Unterabschnitten~\ref{subsubsec:dynamische-typisierung},~\ref{subsubsec:optionale-syntax} und~\ref{subsubsec:strings} näher eingegangen.

	Zu beachten ist, dass es sich zwar um ein Skript handelt, aber Groovy dennoch in jedem Fall vor der Ausführung kompiliert wird.
	Bei Skripts geschieht dieser Schritt jedoch ohne dass zusätzliche Dateien gespeichert werden;
	der generierte Bytecode wird nur im Arbeitsspeicher zwischengespeichert und am Ende der Ausführung verworfen.

	\subsection{Vergleich mit Java}\label{subsec:vergleichMitJava}

	Da ein Großteil der Sprachelemente und deren Syntax direkt übernommen wurde, ist es möglich, viele Java-Programme direkt als Groovy-Programm zu verwenden.
	Dies hat einerseits den Vorteil, dass bei der Überführung eines Projekts von Java zu Groovy zunächst nur wenige Änderungen vorgenommen werden müssen.
	Andererseits macht es das Erlernen der Sprache für Entwickler mit einem Java-Hintergrund einfacher, da sie direkt gültigen Groovy-Code schreiben können und sich mit der Zeit spezifische Konzepte aneignen können.

	Es gibt jedoch einige Fälle, in denen ein Java-Programm nicht auch ein Groovy-Programm ist.
	Triviale Beispiele sind jene Programme, in denen Schlüsselwörter von Groovy als Bezeichner verwendet werden.
	Zu den Kontrollstrukturen, die Groovy in Version 2 nicht unterstützt, gehören Do-While-Schleifen, Try-With-Resource- Blöcke und Block-Statements.
	Die Java-Syntax für Lambda-Ausdrücke, Methoden-Referenzen und Array-Initialisierung werden von dieser Version auch nicht unterstützt.
	In Groovy 3~\cite{groovy-lang:release3}, welches sich derzeit in Entwicklung befindet, werden jedoch mithilfe eines neuen Parsers Bemühungen betrieben, auch diese Sprachelemente zu erlauben und somit den Umstieg weiter zu erleichtern.

	Unterschiede können auch bei Programmen auftreten, die in beiden Sprachen syntaktisch gültig sind, da sich in einigen Fällen die Semantik in Groovy anders als in Java verhält.
	Dazu gehören das implizite Importieren von Pakete zusätzlich zu \code{java.lang}, dazu gehören {u.a.} \code{java.io}, \code{java.net}, \code{java.util}, \code{groovy.lang} und \code{groovy.util}, sowie die Klassen \code{java.math.BigInteger} und \code{java.math.BigDecimal}.
	Weiterhin verhalten sich innere und geschachtelte Klassen, String- und Char-Literale und Typkonvertierungen zwischen primitiven Typen, Wrapper-Typen, \code{BigInteger} und \code{BigDecimal} anders als in Java.

	Weitere Informationen und Beispiele zu den oben genannten Unterschieden sind bei~\cite{groovy-lang:differences} zu finden.

	\subsubsection{Dynamische Typisierung}\label{subsubsec:dynamische-typisierung}

	\subsubsection{Prototyp-Erweiterung}

	\subsubsection{Multi-Methoden}

	Unter Multi-Methoden versteht man eine besondere Art der Semantik von Methodenaufrufen.
	Es handelt sich um eine Form des Polymorphismus, bei der die aufzurufende Methode nicht nur anhand des Laufzeittyps des Empfängers, sondern auch anhand der Typen der Argumente ausgewählt wird.
	In Java werden Methodenaufrufe, bei denen der Aufruf vom Laufzeittyp des Empfängers abhängt, als "virtuell" bezeichnet.
	Dabei ist das \emph{Überschreiben} von Methoden in Unterklassen von Bedeutung.
	Orthogonal dazu gibt es die Möglichkeit, Methoden zu \emph{überladen}.
	Dies bezeichnet das Deklarieren von zwei oder mehr Methoden im gleichen Kontext, die denselben Namen besitzen und sich in der Anzahl der Parameter oder deren Typen unterscheiden.
	Beim Aufruf dieser Methoden wird abhängig von den zur Kompilierungszeit bestimmten Typen der Argument ausgewählt, welche Methode aufgerufen wird.
	Zur Laufzeit sind die Typen der Argument für die Auswahl der Methode dann nicht mehr relevant.

	\codelisting{groovy}{multi-methods.groovy}{Multi-Methoden in Groovy}

	Zur Verdeutlichung des Verhaltens von Groovy soll Listing~\ref{lst:multi-methods.groovy} betrachtet werden.
	Wenn das Programm ausgeführt wird, ist die Assertion erfolgreich und es wird nichts ausgegeben.
	Grund dafür ist, dass die \code{take}-Methode aufgerufen wird, welche einen \code{String} erwartet.
	Der Laufzeittyp des Arguments \code{o} ist \code{String}, während der statische Typ \code{Object} ist.
	In Java würde die Methodenauswahl zur Kompilierungszeit erfolgen und die \code{take(Object)}-Variante bevorzugen, da dort beim Überladen nur der statische Typ relevant ist.

	\subsection{Besonderheiten}\label{subsec:besonderheiten}

	\subsubsection{Zahlen}

	\subsubsection{Zeichenketten}\label{subsubsec:strings}

	\subsubsection{Listen und Maps}

	\subsubsection{Null-Sicherheit}

	\subsubsection{Optionale Syntax}\label{subsubsec:optionale-syntax}

	\subsubsection{Closures}

	\subsubsection{AST-Transformation}

	% --------------- ---------------

	\section{Community, Einsatz und Verbreitung}\label{sec:community}

	Groovy wird von vielen Unternehmen verwendet, unter anderen Google, IBM und LinkedIn~\cite{groovy-lang:main,wiki:Groovy}.

	\subsection{Gradle}\label{subsec:gradle}

	\subsection{Grails}\label{subsec:grails}

	\subsection{Griffon}\label{subsec:griffon}

	% --------------- ---------------

	\section{Zusammenfassung}\label{sec:zusammenfassung}

	% --------------- ---------------

	\bibliography{main}
	\bibliographystyle{ieeetr}

	% --------------- ---------------
\end{document}
