%%
%% Author: adriankunz
%% 2018-12-28
%%

% =============== Preamble ===============

% --------------- Definitions ---------------
\newcommand{\paperTitle}[0]{Die Sprache Groovy}
\newcommand{\paperSubtitle}[0]{Seminar Skriptsprachen, Wintersemester 2018/19}
\newcommand{\paperDate}[0]{\today}
\newcommand{\paperKeywords}[0]{Groovy, Seminar, Skriptsprachen}
\newcommand{\paperAuthor}[0]{Adrian Kunz}

% --------------- Document Setup ---------------
\documentclass[a4paper]{article}
\usepackage[left=2.5cm,right=2.5cm,top=2.5cm,bottom=2cm]{geometry}

\title{\paperTitle}
\author{\paperAuthor}
\date{\paperDate}

% --------------- Packages ---------------
\usepackage[ngerman]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{url}

% Minted
\usepackage{minted}
\usemintedstyle{vs}
\setminted{frame=single,tabsize=2,linenos}

\newmintinline[code]{groovy}{}
\newmintinline[plain]{text}{breaklines}

\newcommand{\codelisting}[3]{
\begin{listing}[ht]
	\inputminted{#1}{#1/#2}
	\caption{#3}
	\label{lst:#2}
\end{listing}
}

% Hyperref
\usepackage{hyperref}
\hypersetup{
pdftitle={\paperTitle{}},
pdfauthor={\paperAuthor{}},
pdfsubject={\paperTitle{}},
pdfkeywords={\paperKeywords},
bookmarksnumbered=true,
bookmarksopen=true,
hidelinks,
}
\usepackage{hypcap}

% =============== Document ===============

\begin{document}
% --------------- ---------------

\maketitle

% --------------- ---------------

\section{Einleitung}\label{sec:einleitung}

Die am meisten genutzte Programmiersprache der Welt ist Java~\cite{tiobe-index}.
Die Möglichkeit, portable und sichere Programme zu schreiben und sich dabei auf eine große Anzahl von Bibliotheken verlassen zu können, begründen diesen Status.
Doch die Sprache hat auch Schwächen:
Selbst für einfachste Programme wie ein Hello World benötigt man mehrere Zeilen Java-Code.
Skripte, welche per Definition sehr kurz sind, sind daher in Java undenkbar.

Das dachte sich wohl auch James Strachan im Jahre 2003, als er mit einem Blogpost~\cite{james-strachan-blog} die Skriptsprache \emph{Groovy} ankündigte.
Sie sollte dynamisch typisiert sein, aber für die Java Virtual Machine kompiliert werden und somit bestehende Java-Bibliotheken und -Code nutzen können.
Die bereits existierenden JRuby-, Jython- und Rhino-Skriptsprachen, welche die Verwendung von Ruby, Python und JavaScript auf der JVM ermöglichten, reichten ihm dafür nicht aus.
Ein Design-Ziel der neuen Sprache war, durch kompakte Syntax spezialisierte Einsatzgebiete wie Test-Driven Development (TDD) zu gewinnen, bei denen auch die Typisierung weniger wichtig ist.

Im März 2004 wurde Groovy dem Java Community Process unter Java Specification Request 241 eingereicht~\cite{jcp:jsr241}.
Nach einigen Vorgängerversionen und der Standardisierung wurde schließlich Version 1.0 am 2. Januar 2007 veröffentlicht.
Am 18. November 2015 wurde das Groovy-Projekt nach einer Inkubationsphase von der Apache Foundation aufgenommen~\cite{apache-incubator:groovy} und seither weiterentwickelt.
Die aktuelle stabile Version ist 2.5.3, welche am 10. Oktober 2018 erschien; nebenbei wird aber schon an Version 3 der Sprache gearbeitet.

In dieser Arbeit soll die Skriptsprache Groovy behandelt werden.
Die Eignung für Domain-Specific Languages (DSLs), für die Strachen in dem Blogpost das Beispiel TDD gab, soll im Folgenden besondere Aufmerksamkeit erhalten.
In Abschnitt~\ref{sec:sprache}, wo Besonderheiten der Sprache in Syntax und Semantik betrachtet werden, werden dafür die Grundlagen erläutert.
Danach wird das Ökosystem um Groovy sowie zwei der wichtigsten Frameworks, welche sich die Sprachbesonderheiten zunutze machen, in Abschnitt~\ref{sec:community} betrachtet.

% --------------- ---------------

\section{Sprache}\label{sec:sprache}

Im folgenden Abschnitt wird Groovy als Sprache vorgestellt.
Die Syntax ist stark an Java und andere C-ähnliche Sprachen angelehnt.
Deshalb wird im Unterabschnitt~\ref{subsec:vergleichMitJava} ein Vergleich mit Java durchgeführt.
In Unterabschnitt~\ref{subsec:besonderheiten} werden neue Sprachelemente und Besonderheiten dargestellt.

Bei Groovy handelt es sich primär um eine Skriptsprache.
Groovy-Programme sollten somit einfach auszuführen sein, möglichst ohne Zwischenschritte wie etwa ein Aufruf eines Compilers.
Dies ist mit dem \code{groovy}-Programm möglich, welches eine gegebene Datei direkt als Groovy-Skript ausführt.
Ähnlich wie bei Bash oder Python können Groovy-Dateien (\code{.groovy}) aber auch mit einer Shebang\footnote{Auf UNIX-basierten Betriebssystem geben die Zeichen ``\#!'' am Anfang einer Datei an, dass diese mit dem darauffolgenden Befehl ausgeführt werden soll.}-Zeile beginnen, um sie direkt ausführbar zu machen.
Variablen und Anweisungen können direkt in der obersten Ebene platziert werden, ebenso Imports, Klassen und Methoden.
Das Listing~\ref{lst:hello-world.groovy} zeigt ein einfaches Hello-World-Programm, welches sich dies zunutze macht.

\codelisting{groovy}{hello-world.groovy}{Hello World in Groovy}

Es kann mit dem Befehl \code{groovy hello-world.groovy}, durch das Shebang aber auch direkt als \code{./hello-world.groovy} ausgeführt werden\footnote{Dafür muss der Programmcode in einer Datei namens \code{hello-world.groovy} gespeichert werden; der Aufruf via Shebang setzt voraus, dass diese ausführbar ist.}.
Die Ausgabe ist in beiden Fällen \plain{Hello World!}.
Auffällig ist das Schlüsselwort \code{def}, die Interpolation in der Zeichenkette und der Methodenaufruf von \code{println} ohne Klammern.
Auf diese wird jeweils in den Unterabschnitten~\ref{subsubsec:typisierung},~\ref{subsubsec:strings} und~\ref{subsubsec:optionale-syntax} näher eingegangen.

Zu beachten ist, dass es sich zwar um ein Skript handelt, aber die Groovy-Laufzeit diese vor der Ausführung immer vollständig kompiliert.
Bei Skripts geschieht dieser Schritt jedoch ohne dass zusätzliche Dateien gespeichert werden;
der generierte Bytecode wird nur zwischengespeichert und nach der Ausführung verworfen.

\subsection{Vergleich mit Java}\label{subsec:vergleichMitJava}

Da ein Großteil der Sprachelemente und deren Syntax direkt übernommen wurde, können viele Java-Programme direkt als Groovy-Programm verwendet werden.
Dies hat einerseits den Vorteil, dass bei der Überführung eines Projekts von Java zu Groovy zunächst nur wenige Änderungen vorgenommen werden müssen.
Andererseits macht es das Erlernen der Sprache für Entwickler mit einem Java-Hintergrund einfacher, da sie direkt gültigen Groovy-Code schreiben können und sich mit der Zeit spezifische Konzepte aneignen können.

In einigen Fällen ist ein gültiges Java-Programm jedoch nicht gleich ein gültiges Groovy-Programm.
Triviale Beispiele sind jene Programme, in denen Schlüsselwörter von Groovy als Bezeichner verwendet werden.
Zu den Kontrollstrukturen, die Groovy in Version 2 nicht unterstützt, gehören Do-While-Schleifen, Try-With-Resource- Blöcke und Block-Statements.
Die Java-Syntax für Lambda-Ausdrücke, Methoden-Referenzen und Array-Initialisierung werden von dieser Version auch nicht unterstützt.
In Groovy 3~\cite{groovy-lang:release3}, welches sich derzeit in Entwicklung befindet, werden jedoch mithilfe eines neuen Parsers Bemühungen betrieben, auch diese Sprachelemente zu erlauben und somit den Umstieg weiter zu erleichtern.

Unterschiede können auch bei Programmen auftreten, die in beiden Sprachen syntaktisch gültig sind, da sich in einigen Fällen die Semantik in Groovy anders als in Java verhält.
Dazu gehören das implizite Importieren von Pakete zusätzlich zu \code{java.lang}, darunter u.a.~\code{java.io}, \code{java.net}, \code{java.util}, \code{groovy.lang} und \code{groovy.util}, sowie die Klassen \code{BigInteger} und \code{BigDecimal} aus \code{java.math}.
Skripts, die auf Dateien oder das Internet zugreifen oder genaue Berechnungen durchführen, kommen also ohne zusätzliche Import-Deklarationen aus und sind dementsprechend kürzer.
Weiterhin verhalten sich innere und geschachtelte Klassen, String- und Char-Literale und Typkonvertierungen zwischen primitiven Typen, Wrapper-Typen, \code{BigInteger} und \code{BigDecimal} anders als in Java.
Weitere Informationen und Beispiele zu den oben genannten Unterschieden sind bei~\cite{groovy-lang:differences} sowie in den nachfolgenden Unterabschnitten zu finden.

\subsubsection{Typisierung}\label{subsubsec:typisierung}

Das Typsystem von Groovy ist standardmäßig dynamisch und unterstützt Duck-Typisierung~\cite[Abs.~6.]{groovy-lang:semantics}.
An vielen Stellen werden implizite Typkonvertierung, beispielsweise von und zu Strings oder Booleans durchgeführt~\cite[Abs.~3.]{groovy-lang:semantics}.
Typinformationen im Code dienen dem Compiler nur als Hilfe um Warnungen auszugeben; Fehler treten jedoch erst zur Laufzeit auf.
Wenn gewünscht ist es aber auch möglich, Typfehler zur Compilezeit zu erzwingen; dafür können die \code{@TypeChecked}- und \code{@CompileStatic}-Annotationen verwendet werden~\cite[Abs.~6.2.]{groovy-lang:semantics}.
Listing~\ref{lst:dynamic-typing.groovy} illustriert das dynamische Verhalten.

\codelisting{groovy}{dynamic-typing.groovy}{Dynamische und Duck-Typisierung}

Zunächst werden zwei Klassen \code{Duck} und \code{Frog} mit je einer \code{quack}-Methode deklariert.
In Zeile 4 wird die \code{duck}-Variable angelegt, der zunächst eine \code{Duck}-Instanz zugewiesen wird.
Der statische Typ der Variable ist durch das \code{def}-Schlüsselwort \code{Object}.
Dennoch ist der Aufruf der \code{quack}-Methode möglich und erzeugt die Ausgabe \plain{I'm a duck}.
In der nächsten Zeile wird ein Objekt einer \code{Frog}-Klasse angelegt, welche die \code{quack}-Methode implementiert.
Der \code{quack}-Aufruf erzeugt nun die Ausgabe \plain{I'm a frog}.
Da \code{duck} als Variable vom Typ \code{Object} deklariert wurde, ist auch die Zuweisung eines Strings erlaubt.
Der Aufruf von \code{quack} auf dem String-Objekt wird vom Compiler nicht abgelehnt, führt jedoch zur Laufzeit zu einer \code{MissingMethodException}.
Ändert man die Deklaration zu \code{Duck duck}, wird schon bei der Zuweisung des \code{Frog}-Objekts vom Compiler eine Warnung angezeigt und zur Laufzeit eine \code{GroovyCastException} erzeugt.

\subsubsection{Multi-Methoden}

Ein Unterschied zu Java, der mit der dynamischen Typisierung in Verbindung steht, ist die Auflösung von Methodenaufrufen.
In Java werden diese dynamisch anhand des Empfängertyps (Überschreiben), aber statisch anhand der Argumenttypen (Überladen) aufgelöst.
Bei Groovy sind auch die Laufzeittypen der Argument für die Auswahl entscheidend, was unter dem Begriff Multi-Methoden bekannt ist.
Das Listing~\ref{lst:multi-methods.groovy} zeigt ein einfaches Beispiel dafür.

\codelisting{groovy}{multi-methods.groovy}{Dynamisches Auflösen von überladenen Methoden}

Wenn das Programm ausgeführt wird, ist die Assertion erfolgreich und es wird nichts ausgegeben.
Grund dafür ist, dass die \code{take}-Methode aufgerufen wird, welche einen \code{String} erwartet.
Der Laufzeittyp des Arguments \code{arg} ist \code{String}, während der statische Typ der Variable \code{Object} ist.
Dadurch wählt die Groovy-Laufzeitumgebung dynamisch die \code{take(String)}-Methode aus.
In Java würde die Methodenauswahl zur Kompilierungszeit erfolgen und die \code{take(Object)}-Variante bevorzugen, da dort beim Überladen nur der statische Typ relevant ist.

\subsection{Besonderheiten}\label{subsec:besonderheiten}

Trotz der Anlehnung an Java bringt Groovy auch einige Besonderheiten mit sich.
Selbst elementare Sprachkonzepte wie Strings, Zahlen und boolsche Werte sind vielfältiger.
Listen, Maps und andere Datenstrukturen sind einfacher zu verwenden; auch Null-Sicherheit wird durch die Sprache erleichtert.
Optionale Syntax und Closures ermöglichen es, DSLs zu definieren und verwenden.
Durch Prototyp-Erweiterungen können Methoden zur Laufzeit zu Klassen und einzelnen Instanzen hinzugefügt werden.
Auf die oben genannten Sprachkonzepte wird in diesem Unterabschnitt genauer eingegangen.

\subsubsection{Zahlen}\label{subsubsec:zahlen}

Mathematische Konzepte haben eine besondere Bedeutung in Groovy.
In Listing~\ref{lst:numbers.groovy} werden einige Besonderheiten dargestellt.

\codelisting{groovy}{numbers.groovy}{Rechnen mit Zahlen und eigenen Klassen}

In Zeile 2 wird das klassische Beispiel für Fließkommafehler gezeigt, welches in Groovy keine Probleme verursacht, da Literale mit Nachkommastellen ohne explizites Suffix oder Cast vom Typ \code{BigDecimal} sind.
Das Ergebnis von Divisionen von zwei ganzzahligen Werten ist hier auch ein \code{BigDecimal}.
Der Operator \code{**} kann verwendet werden, um die Potenz einer Zahl zu berechnen.

Übliche Operatoren können auch von eigenen Klassen verwendet werden, indem sie Methoden mit besonderen Namen wie \code{plus} für \code{+}, \code{leftShift} für \code{<<} oder \code{next} für \code{++} deklarieren.
Dies macht es möglich, Klassen für mathematische Objekte wie komplexe Zahlen, Brüche oder Polynome zu erstellen und mit Operatoren auszustatten, als wären sie Teil der Sprache.
In Zeile 3 bis 6 ist eine einfache Klasse \code{MyNum} deklariert\footnote{Die Annotation \code{@groovy.transform.Canonical} sorgt dafür, dass ein Konstruktor sowie Standardimplementierungen der Methoden \code{equals}, \code{hashCode} und \code{toString} generiert werden.}, welche durch die \code{plus}-Methode die Addition ihrer Instanzen erlaubt.
Eigene Operatoren können jedoch nicht definiert werden.

In Groovy verhalten sich primitive Datentypen zu Kompilierungs- und Laufzeit wie Objekte ihrer Wrapper-Klassen~\cite[Abs.~10.]{groovy-lang:differences}.
Somit kann man mit ihnen alles machen, was auch bei Objekten möglich ist, beispielsweise Attributzugriff oder Methodenaufrufe.
Das Verhalten von Zahlen und Operatoren ist bei~\cite[Abs.~5.]{groovy-lang:syntax} und ~\cite[Abs.~10.]{groovy-lang:operators} genauer dokumentiert.

\subsubsection{Zeichenketten}\label{subsubsec:strings}

Auch Zeichenketten sind vielfältiger als in Java.
Es existieren sechs Arten von String-Literalen in Groovy:

\begin{itemize}\setlength{\itemsep}{0pt}\setlength{\parskip}{0pt}\setlength{\parsep}{0pt}
\item \code{'single quoted'}, unterstützt keine Interpolation oder Zeilenumbrüche,
\item \code{'''triple single quoted'''}, unterstützt keine Interpolation aber mehrere Zeilen,
\item \code{"double quoted"}, unterstützt Interpolation mit dem \code{$}-Zeichen, aber nur einzeilig,
\item \code{"""triple quoted"""}, unterstützt Interpolation und mehrere Zeilen,
\item \code{/slashy/}, für reguläre Ausdrücke, unterstützt auch Interpolation und Zeilenumbrüche, und
\item \code{$/dollar slashy/$}, ähnlich zu \code{/slashy/} aber mit besonderen Escape-Regeln.
\end{itemize}

Besonders interessant ist hierbei die Interpolation, welche ein einfaches Einsetzen von Werten in Strings erlaubt.
Listing~\ref{lst:string-interpolation.groovy} zeigt, wie diese in String-Literalen zum Einsatz kommt.

\codelisting{groovy}{string-interpolation.groovy}{String-Interpolation und Matching mit regulären Ausdrücken}

Im ersten String-Literal in Zeile 3 wird anstelle von \code{$a} und \code{$b} der Wert der Variablen eingesetzt;
\code{${a+b}} wertet den Ausdruck \code{a+b} aus und setzt das Ergebnis in den resultierenden String ein.

In Zeile 5 wird ein Slashy-String-Literal zusammen mit dem Find-Operator \code{=~} verwendet, um einen String mit einem regulären Ausdruck zu matchen.
Durch den Slashy-String müssen die Escape-Zeichen~\plain{\ } für die Metazeichen nur einmal geschrieben werden; der reguläre Ausdruck wird somit leichter lesbar.
Das Ergebnis des \code{=~}-Operators ist ein \code{Matcher}.
Dieser kann implizit zu einem Bool konvertiert werden, der den Erfolg angibt, und ermöglicht den Zugriff auf die Gruppen des regulären Ausdrucks.

\subsubsection{Listen und Maps}\label{subsubsec:listen-und-maps}

Auch Listen und Maps sind fest in der Syntax von Groovy verankert und haben einen großen Satz von Funktionen, um ihre Verwendung zu erleichtern.
Listing~\ref{lst:lists-and-maps.groovy} illustriert einige Möglichkeiten, Listen und Maps zu verwenden.

\codelisting{groovy}{lists-and-maps.groovy}{Erstellen, Zugriff und Verändern von Listen und Maps}

In Zeile 2 wird zunächst eine Liste mit der \code{[]}-Syntax angelegt;
diese ist ohne explizite Typangabe eine \code{ArrayList}.
In Zeile 4 wird der Index-Operator verwendet, um auf das erste und letzte Element zuzugreifen, dabei ist die Verwendung negativer Zahlen wie etwa in Python möglich.
Danach wird mit dem \code{<<}-Operator ein Element ans Ende der Liste angehängt.
Die 5. Zeile zeigt, dass der Index-Operator auch mehrere Argument sowie Intervalle unterstützt.
Der \code{..}-Operator sowie der nicht-inklusive \code{..<}-Operator sind auch in anderen Kontexten verwendbar, um einfach Intervalle zu definieren, beispielsweise in Foreach-Schleifen.

In Zeile 7 wird eine Map angelegt, zu erkennen an den Schlüssel-Wert-Paaren in den eckigen Klammern.
Bei den Bezeichnern \code{a} und \code{b} handelt es sich nicht um Variablennamen, stattdessen wird hier die Zeichenkette \code{a} bzw. \code{b} als Schlüssel verwendet.
Das erzeugte Objekt verwendet die \code{LinkedHashMap}-Implementierung, damit die Reihenfolge der Schlüssel erhalten bleibt.
Zeile 8 zeigt, wie der Zugriff auf den Wert eines Schlüssels sowohl mit dem Index-Operator als auch mit dem Punkt-Operator möglich ist, als wäre \code{d} eine Klassenvariable.
In der nächsten Zeile werden auch beide Möglichkeiten verwendet, um neue Einträge hinzuzufügen.
Auffällig ist der Zugriff auf unbekannte Schlüssel in Zeile 10, welcher auch mit dem Punkt-Operator möglich ist und in beiden Fällen \code{null} zurückgibt.

Andere Collections und Arrays können durch Coercion von Listen- oder Map-Literalen erzeugt werden.
Weitere Informationen zu Arrays, Listen und Maps sind in~\cite[Abs.~7.-9.]{groovy-lang:syntax} zu finden.

\subsubsection{Null-Sicherheit}

Obwohl Groovy im Kern eine Skriptsprache ist und Sicherheit daher eine kleinere Rolle spielt, ist es dennoch im Bereich Null-Sicherheit besser ausgestattet als Java.
Im Kern stehen dabei zwei sehr nützliche Operatoren, \code{?.} und \code{?:}, welche im Folgenden kurz vorgestellt werden.

Der Safe-Navigation-Operator \code{?.} wird verwendet, um \code{NullPointerException}s zu vermeiden.
Anstelle des \code{.}-Operators für Methodenaufrufe und Attributzugriffe sorgt er dafür, dass das Ergebnis des Aufrufs oder Zugriffs \code{null} ist, wenn der Empfänger \code{null} ist.
Somit ist beispielsweise der Wert von \code{person?.name} gleich \code{null}, wenn \code{person} schon \code{null} ist.

Der \code{?:}-Operator, auch Elvis-Operator genannt, ist syntaktischer Zucker, der Ausdrücke der Form \code{lhs ?: rhs} durch \code{lhs ? lhs : rhs} ersetzt.
Dies erscheint im ersten Moment nicht nützlich, doch durch die Regeln der Groovy Truth~\cite[Abs.~5.]{groovy-lang:semantics}, welche die implizite Konvertierung zu Bool-Werten bestimmen, ist er sehr mächtig.
Eine dieser Regeln besagt, dass \code{null}-Referenzen als \code{falsy}\footnote{In Skriptsprachen wird dieser Begriff häufig für Werte verwendet, die sich in boolschen Ausdrücken wie \code{false} verhalten, aber eigentlich kein boolscher Wert sind.} gelten.
Somit wird \code{rhs} vom Ternary-Operator ausgewählt, wenn \code{lhs} \code{null} ist, und \code{lhs} wenn nicht.
Jedoch können die Regeln auch zu Problemen in der Semantik führen:
Leere Strings, Listen und Maps oder Zahlen mit dem Wert \code{0} gelten neben \code{null}-Referenzen auch als \code{falsy}, weshalb der Elvis-Operators mit solchen Werten als linkem Operand auch den rechten Operand zurückgibt.
In der Praxis ist dies jedoch weniger ein Problem, da Variablen mit eben diesen Datentypen, welche gleichzeitig auch \code{null} werden können, aufgrund der Existenz geeigneterer ``Leer''-Werte kein guter Stil sind.

\subsubsection{Closures}\label{subsubsec:closures}

Konzeptuell sind Closures ähnlich zu Lambda-Ausdrücken in Java, indem sie eine Möglichkeit bieten, Anweisungen wie ein Objekt zu speichern und zu übergeben.
Sie sind sowohl für das Schreiben von kompaktem Code als auch für DSLs unerlässlich.
Listing~\ref{lst:closures-fp.groovy} enthält zunächst einige Beispiele, wie sie für funktionale Operationen auf Listen verwendet werden, welche mit Schleifen o.ä.~erheblich umfangreicher wären.

\codelisting{groovy}{closures-fp.groovy}{Einsatz von Closures für funktionalen Listenoperationen}

Zunächst wird in Zeile 2 eine Liste definiert.
In Zeile 3 wird mithilfe der \code{collect}-Methode eine neue Liste erstellt, die jeweils das Doppelte der Elemente der Ursprungsliste enthält.
Dafür wird eine Closure als Argument übergeben, die einen Parameter \code{it} empfängt und ihn verdoppelt zurückgibt.
Danach werden mit \code{findAll} diejenigen Elemente in eine neue Liste gelegt, die gerade sind.
In Zeile 5 wird mit der \code{inject}-Methode und einer Closure, die zwei Argumente addiert, die Summe der Elemente von \code{list} berechnet.
In funktionalen Programmiersprachen sowie in der Java-\code{Stream}-API sind die Operationen \code{collect}, \code{findAll} und \code{inject} meist als \code{map}, \code{filter} und \code{reduce} bzw. \code{fold} bekannt.

Eine Besonderheit von Closures ist, dass Methodenaufrufe und Feldzugriffe im Rumpf nicht an der Stelle verfügbar sein müssen, wo die Closure erstellt wird.
Dafür wird der \code{delegate}-Mechanismus bereitgestellt, der sehr gut für DSLs geeignet ist und im Listing~\ref{lst:closures-dsl.groovy} gezeigt wird.

\codelisting{groovy}{closures-dsl.groovy}{Verwendung von Closure Delegates für eine Rechenmaschinen-DSL}

Das Programm beginnt mit der Deklaration der Funktion \code{eval}, welche eine Closure akzeptiert und einen Variable \code{result} speichert.
Danach wird dem \code{delegate} der Closure ein Objekt einer anonymen Klasse zugewiesen, welche die Methoden \code{add} und \code{mul} definiert.
Diese verändern entsprechend die \code{result}-Variable mit dem übergebenen Argument.
In Zeile 6 wird die modifizierte Closure aufgerufen und der Wert der Ergebnisvariable ausgegeben.
Die Verwendung der dadurch definierten DSL, einer einfachen Rechenmaschine, folgt in Zeile 8.
Die Closure, die der \code{eval}-Funktion übergeben wird, bezieht sich auf die in diesem Kontext unbekannten Funktionen \code{add} und \code{mul}.
Diese müssen jedoch erst aufgelöst werden, wenn die Closure aufgerufen wird.
Da zu diesem Zeitpunkt schon das \code{delegate} gesetzt ist, können die bisher unbekannten Funktionen nun über dieses aufgelöst werden, und beziehen sich entsprechend auf die Methoden der anonymen Klasse.
Somit kann das Programm erfolgreich ausgeführt werden und gibt \plain{5.5} aus, das Ergebnis der DSL-Rechenmaschine.

\subsubsection{Optionale Syntax}\label{subsubsec:optionale-syntax}

Groovy erlaubt es, Punkt-Operatoren und Klammern bei Methodenaufrufen wegzulassen.
Dies ermöglicht die einfache Erstellung von nahezu natürlichsprachigen DSLs, wie es das Listing~\ref{lst:optional-parens.groovy} zeigt.

\codelisting{groovy}{optional-parens.groovy}{Eine weitere DSL mithilfe von optionalen Klammern und Punkten}

Hier wird zunächst eine Hilfsfunktion \code{make} erstellt, welche die DSL definiert.
Um das Beispiel kurz zu halten, werden hierfür Map-Literale und Closures verwendet, die in den Unterabschnitten~\ref{subsubsec:listen-und-maps} und~\ref{subsubsec:closures} erklärt wurden.
Bei echten DSLs sollten stattdessen Klassen und Methoden verwendet werden.
Hier wurde zusätzlich ausgenutzt, dass die Verwendung des \code{return}-Schlüsselworts auch optional ist.
In Zeile 5 werden aus Illustrationsgründung symbolische Variablen für einige Zeichenketten definiert.
Danach folgt die Verwendung der definierten DSL:
Der Befehl sieht aus wie ein englischer Satz, ist aber semantisch äquivalent zu der Anweisung in Zeile 7.
Bei den aufeinanderfolgenden Bezeichnern werden abwechselnd Punkt-Zugriffe und Methodenaufrufe impliziert.
Die Ausgabe ist zweimal der Satz \plain{my cake contains sugar, eggs and flour}.

Es fällt auch auf, dass bei diesem und anderen Listings an Zeilenenden keine Semikolons gebraucht werden, da auch diese in den meisten Fällen optional sind.
In Listing~\ref{lst:closures-dsl.groovy}, Zeile 8, ist zu beobachten, wie mit einem expliziten Semikolon auch mehrere Anweisungen in einer Zeile stehen können.

\subsubsection{Prototyp-Erweiterung}

Die Prototyp-Erweiterung ist eine weitere Besonderheit der Methodenauflösung von Groovy.
Sie erlaubt es, Klassen und Objekten Eigenschaften und Methoden zur Laufzeit hinzuzufügen, ohne dass der Quellcode geändert werden muss.
In Listing~\ref{lst:prototype-extension.groovy} wird diese zur rekursiven Berechnung der Fakultät von Zahlen verwendet.

\codelisting{groovy}{prototype-extension.groovy}{Fakultätberechnung mit Prototyp-Erweiterungen}

Hier wird zunächst die \code{factorial}-Methode für das \code{Integer}-Objekt der Zahl \code{0} durch eine Closure definiert, welche den Wert \code{1} zurückgibt (Basisfall).
Danach wird allgemein für die \code{Number}-Klasse der Rekursionsfall definiert.
Hier steht \code{delegate} für den Empfänger.
In Zeile 4 wird schließlich die \code{factorial}-Methode aufgerufen.
Dabei wird zur Laufzeit zuerst in der \code{metaClass} der konkreten Instanz nach einer Definition gesucht, danach in der \code{metaClass} des Laufzeittyps.
Der Aufruf \code{0.factorial()} bezieht sich also auf die Definition aus Zeile 2.
Bei \code{5.factorial()} wird fünf Mal die Definition aus Zeile 3 aufgerufen, bevor \code{delegate} gleich \code{1} ist und \code{(delegate - 1).factorial()} auf die Definition für \code{0} verweist.

% --------------- ---------------

\section{Community, Einsatz und Verbreitung}\label{sec:community}

Nach dem technischen Teil zur Sprache soll nun auch das Ökosystem um Groovy betrachtet werden.
Im Januar 2019 ist Groovy auf Platz 21 des Tiobe Index~\cite{tiobe-index} und somit die zweithöchste JVM-Sprache, nach Java.
Die Konkurrenz bilden dabei Scala und Kotlin auf Platz 28.~und 31.
Auf StackOverflow~\cite{stackoverflow:groovy} sind über 22.000 Fragen und Antworten zu Groovy finden.
Durch die Quelloffenheit der Groovy-Implementierung auf GitHub~\cite{github:groovy} kann sich jeder an der Weiterentwicklung und Fehlerbehebung beteiligen.
Da theoretisch jede Java-Bibliothek auch von Groovy-Code verwendbar ist, können sich Entwickler auf über 3,4 Mio. Jar-Artefakte auf Maven Central~\cite{maven-central} verlassen.
Doch auch eigene große Projekte sind auf Groovy entstanden.
Im Folgenden werden kurz zwei dieser Projekte vorgestellt --- Gradle und Grails.

\subsection{Gradle}\label{subsec:gradle}

Gradle~\cite{gradle} ist ein Open-Source-Tool zur Build-Automatisierung, welches in Groovy und Java geschrieben wurde.
Konfiguriert wird es durch Groovy-Skripte, die sich die DSL-Fähigkeiten der Sprache zunutze machen.
Dies hebt es von seinen Vorgängern Apache Ant und Apache Maven, welche XML-Dateien verwenden, durch erhöhte Nutzerfreundlichkeit ab.
Seit dem ersten Release 2005 wurde Gradle stets weiterentwickelt, um neben Java und Groovy auch andere Zielsprachen wie Scala und sogar Python und C++ zu unterstützen.
Gradle ist besonders für große Projekte gut geeignet, da durch inkrementelle Builds nur geänderte Dateien verarbeitet werden müssen.

\subsection{Grails}\label{subsec:grails}

Grails~\cite{grails} ist ein in Groovy geschriebenes Web-Framework, welches quelloffen ist.
Es basiert auf Spring Boot, setzt aber auf Konvention statt Konfiguration, um einen leichteren Einstieg zu erlauben.
Datenbankzugriff wird durch das GORM-Toolkit gewährleistet, welches wiederum Schnittstellen für Hibernate, MongoDB und Cassandra bietet.
HTML-Seiten können mit dem Groovy Server Page-Templatesystem generiert werden.

% --------------- ---------------

\section{Zusammenfassung}\label{sec:zusammenfassung}

Es hat sich gezeigt, dass Groovy da ansetzt, wo Java aufhört --- kurze und prägnante Programme, die mit wenigen Zeilen viel bewirken können.
Anweisungen auf oberster Ebene, optionale Typen und das Auslassen des Kompilierungsschritts ermöglichen Skripte, wie sie von Ruby, Python oder Bash bekannt sind.
Die Sprache gibt dem Entwickler viele Freiheiten bei der Syntax durch Closures und optionalen Zeichen, wodurch mächtige DSLs erstellt und optisch anschaulich genutzt werden können.
Trotz der Skriptnatur ist wenn gewünscht auch für Sicherheit gesorgt;
besonders die in Java häufig kritisierte Nullsicherheit ist in Groovy besser gelöst.
Die vereinfachte Verwendung von Listen und Maps macht sie attraktiver als die auf einer tieferen Sprachebene liegenden Arrays.
Mit der dynamischen Typisierung und dem Überladen von Operatoren hebt es sich auch semantisch von seiner Muttersprache Java ab.

Dennoch profitiert Groovy von seiner Herkunft.
Der leichte Umstieg von Java sowie der Einsatz mit Gradle fördern die Bekanntheit der Skriptsprache.
Die Möglichkeit, die sehr umfangreiche Anzahl von Java-Bibliotheken zu nutzen, sind ein weiterer wichtiger Faktor.
Durch die Standardisierung, die Zugehörigkeit zur Apache Foundation und die Quelloffenheit ist Groovy eine robuste und dennoch stets wachsende Sprache.
Die steigende Popularität von Web-basierten Lösungen macht sich Groovy durch das Grails-Framework zu Nutze.

Insgesamt ist Groovy eine Sprache, die den Entwickler nicht einschränkt.
Sie bietet die Möglichkeit, sehr kurze aber auch sehr lange Programme zu schreiben.
Erstere unter Auslassen von Typinformationen, um möglichst schnell einsatzfähig zu sein;
letztere können mit Typen und statischer Kompilierung wartbar, robust und performant gemacht werden.
Wo Java für kurze und andere Skriptsprachen für lange Programme nicht geeignet sind, setzt Groovy ein und verbindet zwei Welten.

% --------------- ---------------

\bibliography{main}
\bibliographystyle{ieeetr}

% --------------- ---------------
\end{document}
